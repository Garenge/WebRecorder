<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>屏幕录制 Demo</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 40px; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; }
    video { margin-top: 20px; max-width: 100%; border: 1px solid #ccc; }
    
    /* 实时更新动画效果 */
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes flash {
      0% { background-color: transparent; }
      50% { background-color: #ffeb3b; }
      100% { background-color: transparent; }
    }
    
    .cache-updating {
      animation: flash 0.3s ease-in-out;
    }
    
    /* 禁用状态的样式 */
    select:disabled {
      background-color: #f5f5f5;
      color: #999;
      cursor: not-allowed;
    }
    
    select:disabled option {
      color: #999;
    }
  </style>
</head>
<body>
  <h2>Edge 屏幕录制 Demo</h2>
  <div style="margin: 10px 0; padding: 10px; background-color: #f9f9f9; border-radius: 5px;">
    <label for="memoryThreshold">内存阈值设置:</label>
    <select id="memoryThreshold" style="padding: 5px; margin: 5px;">
      <option value="1" selected>1 MB</option>
      <option value="5">5 MB</option>
      <option value="10">10 MB</option>
      <option value="20">20 MB</option>
      <option value="50">50 MB</option>
    </select>
    <span style="color: #666; font-size: 12px;">达到阈值时自动保存文件</span>
    <br>
    <span id="currentThreshold" style="color: #007bff; font-size: 12px; font-weight: bold;">当前阈值: 1 MB</span>
    <br><br>
    <label for="recordingMode">录制模式:</label>
    <select id="recordingMode" style="padding: 5px; margin: 5px;">
      <option value="single" selected>单文件模式 (推荐)</option>
      <option value="multiple">多文件模式</option>
    </select>
    <span style="color: #666; font-size: 12px;">单文件模式会累积所有数据，录制结束时生成一个完整文件</span>
  </div>
  
  <!-- 状态信息区域 -->
  <div style="margin: 10px 0; padding: 10px; background-color: #e8f4fd; border-radius: 5px; border-left: 4px solid #007bff;">
    <strong>当前状态:</strong> <span id="recordingStatus">未录制</span>
    <br>
    <div style="display: flex; align-items: center; margin: 2px 0;">
      <strong style="width: 100px; text-align: left;">当前缓存:</strong>
      <span id="cacheSize" style="min-width: 80px; text-align: right; font-family: monospace; font-weight: bold;">0.00 MB</span>
      <span id="changeIndicator" style="color: #4CAF50; font-weight: bold; margin-left: 5px;"></span>
    </div>
    <div style="display: flex; align-items: center; margin: 2px 0;">
      <strong style="width: 100px; text-align: left;">已保存文件:</strong>
      <span id="savedFiles" style="min-width: 80px; text-align: right; font-family: monospace; font-weight: bold;">0 个</span>
    </div>
    <div style="display: flex; align-items: center; margin: 2px 0;">
      <strong style="width: 100px; text-align: left;">累计录制:</strong>
      <span id="totalRecorded" style="min-width: 80px; text-align: right; font-family: monospace; font-weight: bold;">0.00 MB</span>
    </div>
    <br>
    <div id="filePathInfo" style="margin-top: 10px; padding: 8px; background-color: #f8f9fa; border-radius: 3px; font-size: 12px; display: none;">
      <strong>文件路径:</strong> <span id="currentFilePath">-</span>
    </div>
  </div>
  
  <button id="startBtn">开始录制</button>
  <button id="stopBtn" disabled>停止录制</button>
  <button id="clearMemoryBtn" style="background-color: #ff6b6b; color: white;">清理内存</button>
  <button id="mergeFilesBtn" style="display:none; background-color: #4CAF50; color: white;">合并文件</button>
  <a id="downloadLink" style="display:none;">下载录制视频</a>
  <br>
  <div id="windowInfo" style="margin: 10px 0; padding: 10px; background-color: #f0f0f0; border-radius: 5px; display:none;">
    <strong>正在录制:</strong> <span id="windowName">-</span>
    <br><br>
    <label for="customTitle">自定义录制名称 (可选):</label>
    <input type="text" id="customTitle" placeholder="例如: 产品演示、会议记录等" style="width: 300px; padding: 5px; margin: 5px;">
    <button id="updateTitleBtn" style="padding: 5px 10px;">更新名称</button>
  </div>
  
  <!-- 合并文件对话框 -->
  <div id="mergeDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:white; padding:20px; border:2px solid #ccc; border-radius:10px; z-index:1000; max-width:600px;">
    <h3>合并录制文件</h3>
    <p>选择要合并的文件（按顺序）：</p>
    <div id="fileList" style="max-height:300px; overflow-y:auto; border:1px solid #ddd; padding:10px; margin:10px 0;"></div>
    <button id="confirmMergeBtn" style="background-color:#4CAF50; color:white; padding:10px 20px; margin:5px;">确认合并</button>
    <button id="cancelMergeBtn" style="background-color:#f44336; color:white; padding:10px 20px; margin:5px;">取消</button>
  </div>
  
  <video id="preview" autoplay muted></video>

  <script>
    let mediaRecorder;
    let recordedChunks = [];
    let currentWindowName = "未知窗口";
    let memoryUsage = { chunks: 0, size: 0 };
    let savedFileCount = 0;
    let savedFiles = []; // 存储已保存的文件信息
    let isStreamingMode = true; // 启用流式录制模式
    let sessionId = ""; // 录制会话ID，用于文件命名
    let sessionFiles = []; // 当前会话的所有文件
    let totalRecordedSize = 0; // 累计录制的总大小
    let isUpdatingDisplay = false; // 防止重复更新显示
    let lastUpdateTime = 0; // 上次更新时间
    
    // 新增：单文件追加写入相关变量
    let allRecordedChunks = []; // 存储所有录制数据块
    let isSingleFileMode = true; // 是否使用单文件模式
    let currentFileBlob = null; // 当前累积的文件Blob
    let finalFileName = ""; // 最终文件名
    let updateTimer = null; // 定时更新器
    let singleFilePath = ""; // 单文件路径
    let singleFileBlob = null; // 单文件Blob
    let memoryChunks = []; // 内存中的数据块（限制大小）
    let maxMemorySize = 100 * 1024 * 1024; // 内存最大100MB
    let diskChunks = []; // 磁盘上的数据块引用

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const preview = document.getElementById("preview");
    const downloadLink = document.getElementById("downloadLink");
    const windowInfo = document.getElementById("windowInfo");
    const windowNameSpan = document.getElementById("windowName");
    const customTitleInput = document.getElementById("customTitle");
    const updateTitleBtn = document.getElementById("updateTitleBtn");
    const clearMemoryBtn = document.getElementById("clearMemoryBtn");
    const cacheSizeSpan = document.getElementById("cacheSize");
    const savedFilesSpan = document.getElementById("savedFiles");
    const recordingStatusSpan = document.getElementById("recordingStatus");
    const totalRecordedSpan = document.getElementById("totalRecorded");
    const memoryThresholdSelect = document.getElementById("memoryThreshold");
    const mergeFilesBtn = document.getElementById("mergeFilesBtn");
    const mergeDialog = document.getElementById("mergeDialog");
    const fileList = document.getElementById("fileList");
    const confirmMergeBtn = document.getElementById("confirmMergeBtn");
    const cancelMergeBtn = document.getElementById("cancelMergeBtn");
    const currentThresholdSpan = document.getElementById("currentThreshold");
    const recordingModeSelect = document.getElementById("recordingMode");
    const filePathInfo = document.getElementById("filePathInfo");
    const currentFilePath = document.getElementById("currentFilePath");
    
    // 统一的录制停止处理函数
    function handleRecordingStop() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      // 停止所有轨道
      if (preview.srcObject) {
        preview.srcObject.getTracks().forEach(track => track.stop());
      }
      
      // 清除定时更新器
      if (updateTimer) {
        clearInterval(updateTimer);
        updateTimer = null;
      }
      
      // 重新启用设置控件
      toggleSettingsEnabled(true);
      
      // 隐藏窗口信息
      windowInfo.style.display = "none";
      
      // 显示最终状态
      updateCacheDisplay();
      updateRecordingStatus("录制已停止");
      console.log("录制已停止，界面状态已更新");
      console.log(`已保存文件数量: ${savedFileCount} 个`);
    }
    
    // 更新录制标题的功能
    function updateRecordingTitle() {
      const customTitle = customTitleInput.value.trim();
      if (customTitle) {
        // 移除时间戳，只保留自定义标题
        const baseName = customTitle;
        currentWindowName = baseName;
        windowNameSpan.textContent = currentWindowName;
        console.log("录制标题已更新为:", currentWindowName);
      } else {
        alert("请输入一个有效的标题");
      }
    }
    
    // 绑定更新标题按钮事件
    updateTitleBtn.onclick = updateRecordingTitle;
    
    // 支持回车键更新标题
    customTitleInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        updateRecordingTitle();
      }
    });
    
    // 生成会话ID
    function generateSessionId() {
      const now = new Date();
      const timestamp = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0') + '_' +
        String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      return timestamp;
    }
    
    // 实时更新缓存大小显示 - 修复版本
    function updateCacheDisplay(forceUpdate = false) {
      // 重新计算当前缓存大小
      memoryUsage.chunks = recordedChunks.length;
      memoryUsage.size = recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
      const sizeMB = (memoryUsage.size / 1024 / 1024).toFixed(2);
      
      // 计算总累积大小（所有数据块的总和）
      const totalAccumulatedSize = allRecordedChunks.reduce((total, chunk) => total + chunk.size, 0);
      const totalAccumulatedMB = (totalAccumulatedSize / 1024 / 1024).toFixed(2);
      
      // 直接更新DOM，确保实时刷新
      if (cacheSizeSpan) {
        // 简单格式化，避免抖动
        cacheSizeSpan.textContent = `${sizeMB} MB`;
        savedFilesSpan.textContent = `${savedFileCount} 个`;
        
        // 显示总累积大小，让用户看到成就感
        totalRecordedSpan.textContent = `${totalAccumulatedMB} MB`;
        
        // 添加实时变化指示器
        const changeIndicator = document.getElementById('changeIndicator');
        if (changeIndicator) {
          changeIndicator.textContent = '●'; // 实心圆点表示正在更新
          changeIndicator.style.color = '#4CAF50';
          changeIndicator.style.animation = 'pulse 0.3s ease-in-out';
          setTimeout(() => {
            if (changeIndicator) {
              changeIndicator.textContent = '';
              changeIndicator.style.animation = '';
            }
          }, 300);
        }
        
        // 调试信息 - 显示详细数据（减少输出频率）
        if (memoryUsage.chunks % 5 === 0) { // 每5个数据块输出一次
          console.log(`🔄 实时更新: 当前缓存 ${sizeMB} MB (${memoryUsage.chunks} 个数据块), 总累积 ${totalAccumulatedMB} MB (${allRecordedChunks.length} 个数据块)`);
        }
      } else {
        console.error("❌ cacheSizeSpan 元素未找到！");
      }
      
      return sizeMB;
    }
    
    // 更新录制状态
    function updateRecordingStatus(status) {
      recordingStatusSpan.textContent = status;
      console.log(`录制状态更新: ${status}`);
    }
    
    // 更新文件路径显示
    function updateFilePathDisplay(filePath) {
      if (filePath) {
        currentFilePath.textContent = `浏览器默认下载目录/${filePath}`;
        filePathInfo.style.display = "block";
        console.log(`📁 文件路径更新: ${filePath}`);
      } else {
        filePathInfo.style.display = "none";
        currentFilePath.textContent = "-";
      }
    }
    
    // 保存内存数据到磁盘（控制内存使用）
    function saveMemoryToDisk() {
      if (memoryChunks.length === 0) return;
      
      const memoryBlob = new Blob(memoryChunks, { type: "video/webm" });
      
      // 将内存数据保存到磁盘引用
      diskChunks.push({
        blob: memoryBlob,
        size: memoryBlob.size,
        timestamp: Date.now()
      });
      
      console.log(`💾 保存内存数据到磁盘: ${(memoryBlob.size / 1024 / 1024).toFixed(2)} MB`);
      console.log(`🧹 清理内存数据: ${memoryChunks.length} 个数据块`);
      
      // 清空内存数据块，释放内存
      memoryChunks = [];
      
      console.log(`✅ 内存数据已保存到磁盘，内存已释放`);
    }
    
    // 管理设置控件的启用/禁用状态
    function toggleSettingsEnabled(enabled) {
      memoryThresholdSelect.disabled = !enabled;
      recordingModeSelect.disabled = !enabled;
      
      // 添加视觉反馈
      if (enabled) {
        memoryThresholdSelect.style.opacity = "1";
        recordingModeSelect.style.opacity = "1";
        memoryThresholdSelect.style.backgroundColor = "";
        recordingModeSelect.style.backgroundColor = "";
        memoryThresholdSelect.style.cursor = "pointer";
        recordingModeSelect.style.cursor = "pointer";
      } else {
        memoryThresholdSelect.style.opacity = "0.6";
        recordingModeSelect.style.opacity = "0.6";
        memoryThresholdSelect.style.backgroundColor = "#f5f5f5";
        recordingModeSelect.style.backgroundColor = "#f5f5f5";
        memoryThresholdSelect.style.cursor = "not-allowed";
        recordingModeSelect.style.cursor = "not-allowed";
      }
      
      console.log(`设置控件已${enabled ? '启用' : '禁用'}`);
    }
    
    // 流式保存功能 - 真正的流媒体保存
    function saveCurrentChunks() {
      if (recordedChunks.length === 0) {
        console.log(`⚠️ 没有数据需要保存，recordedChunks.length = 0`);
        return;
      }
      
      console.log(`🔄 开始保存数据块...`);
      console.log(`📊 保存前状态: 当前缓存 ${recordedChunks.length} 个数据块, 总累积 ${allRecordedChunks.length} 个数据块`);
      
      if (isSingleFileMode) {
        // 单文件模式：累积到阈值后更新单文件，控制内存使用
        console.log(`📁 单文件模式: 达到阈值，累积数据块 ${recordedChunks.length} 个，当前缓存大小 ${(memoryUsage.size / 1024 / 1024).toFixed(2)} MB`);
        
        // 将当前缓存数据添加到内存数据块
        memoryChunks.push(...recordedChunks);
        
        // 检查内存大小，如果超过限制则保存到磁盘
        const memorySize = memoryChunks.reduce((total, chunk) => total + chunk.size, 0);
        
        if (memorySize >= maxMemorySize) {
          // 保存内存数据到磁盘
          saveMemoryToDisk();
        }
        
        // 将数据添加到总累积数据
        allRecordedChunks.push(...recordedChunks);
        
        // 创建或更新单文件路径显示
        if (!singleFilePath) {
          singleFilePath = `${currentWindowName}_${sessionId}_录制中.webm`;
          console.log(`📁 创建单文件: ${singleFilePath}`);
          console.log(`📍 单文件地址: 浏览器默认下载目录/${singleFilePath}`);
          console.log(`💡 注意: 单文件将定期更新，控制内存使用`);
          updateFilePathDisplay(singleFilePath);
        }
        
        // 更新单文件Blob（包含所有累积数据）
        singleFileBlob = new Blob(allRecordedChunks, { type: "video/webm" });
        
        // 下载更新的单文件（覆盖之前的版本）
        const url = URL.createObjectURL(singleFileBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = singleFilePath;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log(`📦 更新单文件: ${singleFilePath} (${(singleFileBlob.size / 1024 / 1024).toFixed(2)} MB)`);
        console.log(`📊 总累积数据块: ${allRecordedChunks.length} 个`);
        console.log(`💾 单文件已更新到下载目录`);
        
        // 清空当前缓存
        const beforeClear = recordedChunks.length;
        recordedChunks = [];
        console.log(`🧹 清空当前缓存: ${beforeClear} 个数据块 -> 0 个数据块`);
        
        // 更新显示
        updateCacheDisplay();
        
        console.log(`📊 保存后状态: 当前缓存 0 个数据块, 内存数据 ${memoryChunks.length} 个数据块, 总累积 ${allRecordedChunks.length} 个数据块`);
        console.log(`📊 内存使用: ${(memorySize / 1024 / 1024).toFixed(2)} MB / ${(maxMemorySize / 1024 / 1024).toFixed(2)} MB`);
        console.log(`========================================`);
      } else {
        // 多文件模式：保存为小文件
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const partNumber = String(sessionFiles.length + 1).padStart(3, '0');
        const fileName = `${currentWindowName}_${sessionId}_part${partNumber}.webm`;
        
        // 创建下载链接
        const link = document.createElement('a');
        link.href = url;
        link.download = fileName;
        link.style.display = 'none';
        document.body.appendChild(link);
        
        // 自动下载
        link.click();
        
        // 清理
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        // 保存文件信息到会话
        const fileInfo = {
          fileName: fileName,
          size: blob.size,
          timestamp: new Date().toLocaleString(),
          partNumber: partNumber,
          sessionId: sessionId
        };
        
        sessionFiles.push(fileInfo);
        savedFiles.push(fileInfo);
        savedFileCount++;
        
        console.log(`已保存第 ${savedFileCount} 个文件: ${fileName} (${(blob.size / 1024 / 1024).toFixed(2)} MB)`);
        
        // 清空当前缓存
        recordedChunks = [];
        updateCacheDisplay();
      }
    }
    
    // 检查是否需要保存
    function checkMemoryThreshold() {
      const thresholdMB = parseInt(memoryThresholdSelect.value);
      const currentSizeMB = updateCacheDisplay();
      
      console.log(`🔍 阈值检查: 当前 ${currentSizeMB} MB / 阈值 ${thresholdMB} MB`);
      
      if (currentSizeMB >= thresholdMB) {
        console.log(`🚨 达到阈值！当前 ${currentSizeMB} MB >= 阈值 ${thresholdMB} MB`);
        console.log(`💾 开始保存文件...`);
        saveCurrentChunks();
        console.log(`✅ 文件保存完成，缓存已清空`);
      } else {
        console.log(`⏳ 未达到阈值，继续累积... (还需要 ${(thresholdMB - currentSizeMB).toFixed(2)} MB)`);
      }
    }
    
    // 清理内存
    function clearMemory() {
      recordedChunks = [];
      allRecordedChunks = []; // 清理总累积数据
      memoryUsage = { chunks: 0, size: 0 };
      savedFileCount = 0;
      savedFiles = [];
      sessionFiles = [];
      sessionId = "";
      totalRecordedSize = 0; // 重置累计大小
      currentFileBlob = null; // 清理当前文件Blob
      finalFileName = ""; // 清理最终文件名
      
      // 清除定时更新器
      if (updateTimer) {
        clearInterval(updateTimer);
        updateTimer = null;
      }
      
      // 清理单文件相关变量
      singleFilePath = "";
      singleFileBlob = null;
      memoryChunks = [];
      diskChunks = [];
      updateFilePathDisplay(null); // 隐藏文件路径显示
      
      // 重新启用设置控件
      toggleSettingsEnabled(true);
      
      mergeFilesBtn.style.display = "none";
      downloadLink.style.display = "none";
      updateCacheDisplay();
      updateRecordingStatus("未录制");
      console.log("🧹 内存已清理，所有录制数据已删除");
      alert("🧹 内存已清理，录制数据已删除");
    }
    
    // 绑定清理内存按钮事件
    clearMemoryBtn.onclick = () => {
      if (confirm("确定要清理内存吗？这将删除所有录制数据，无法恢复！")) {
        clearMemory();
      }
    };
    
    // 合并文件功能
    function showMergeDialog() {
      if (sessionFiles.length === 0) {
        alert("没有文件可以合并");
        return;
      }
      
      // 清空文件列表
      fileList.innerHTML = "";
      
      // 添加说明文字
      const infoDiv = document.createElement('div');
      infoDiv.style.cssText = 'padding:10px; background-color:#f0f8ff; border-radius:5px; margin-bottom:10px; font-size:12px; color:#666;';
      infoDiv.innerHTML = `📁 本次录制共 ${sessionFiles.length} 个文件（默认全选）<br>💡 只包含当前会话的文件，不包括之前录制的文件`;
      fileList.appendChild(infoDiv);
      
      // 添加文件选择项
      sessionFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.style.cssText = 'padding:5px; border-bottom:1px solid #eee; display:flex; align-items:center;';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true; // 默认全选
        checkbox.id = `file_${index}`;
        
        const label = document.createElement('label');
        label.htmlFor = `file_${index}`;
        label.textContent = `${file.fileName} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
        label.style.cssText = 'margin-left:10px; flex:1;';
        
        fileItem.appendChild(checkbox);
        fileItem.appendChild(label);
        fileList.appendChild(fileItem);
      });
      
      mergeDialog.style.display = 'block';
    }
    
    // 自动合并所有文件（多文件模式录制结束时调用）
    function autoMergeFiles() {
      if (sessionFiles.length === 0) {
        console.log("没有文件可以合并");
        return;
      }
      
      console.log(`🔄 自动合并 ${sessionFiles.length} 个文件...`);
      
      // 按partNumber排序
      const sortedFiles = [...sessionFiles].sort((a, b) => a.partNumber.localeCompare(b.partNumber));
      
      console.log("=== 自动合并文件路径信息 ===");
      sortedFiles.forEach((file, index) => {
        console.log(`${index + 1}. ${file.fileName}`);
        console.log(`   路径: 浏览器默认下载目录/${file.fileName}`);
        console.log(`   大小: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
      });
      
      // 创建合并后的文件名
      const mergedFileName = `${currentWindowName}_${sessionId}_自动合并.webm`;
      
      // 使用累积的数据创建合并文件
      const mergedBlob = new Blob(allRecordedChunks, { type: "video/webm" });
      const url = URL.createObjectURL(mergedBlob);
      
      // 创建下载链接
      const link = document.createElement('a');
      link.href = url;
      link.download = mergedFileName;
      link.style.display = 'none';
      document.body.appendChild(link);
      
      // 自动下载
      link.click();
      
      // 清理
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      console.log(`✅ 自动合并完成: ${mergedFileName} (${(mergedBlob.size / 1024 / 1024).toFixed(2)} MB)`);
      console.log(`💾 合并文件已下载到: 浏览器默认下载目录/${mergedFileName}`);
      
      // 询问是否尝试自动删除源文件
      if (confirm(`✅ 合并完成！\n📁 合并文件: ${mergedFileName}\n📊 总大小: ${(mergedBlob.size / 1024 / 1024).toFixed(2)} MB\n\n是否尝试自动删除 ${sessionFiles.length} 个源文件？\n🔧 将尝试多种方法自动删除`)) {
        deleteSourceFiles();
      }
    }
    
    // 尝试自动删除源文件（多种方法）
    function deleteSourceFiles() {
      const fileCount = sessionFiles.length;
      const filesToDelete = [...sessionFiles]; // 保存文件信息副本
      
      console.log(`🗑️ 开始尝试自动删除 ${fileCount} 个源文件...`);
      
      // 显示要删除的文件列表
      if (fileCount > 0) {
        console.log("📁 尝试删除的源文件:");
        filesToDelete.forEach((file, index) => {
          console.log(`${index + 1}. ${file.fileName} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
        });
      }
      
      // 方法1: 尝试使用 File System Access API (Chrome 86+)
      if ('showDirectoryPicker' in window) {
        console.log("🔧 尝试使用 File System Access API...");
        tryDeleteWithFileSystemAPI(filesToDelete);
      } else {
        console.log("❌ File System Access API 不支持，尝试其他方法...");
        tryAlternativeDeleteMethods(filesToDelete);
      }
      
      // 清空文件列表和相关数据
      sessionFiles = [];
      allRecordedChunks = [];
      totalRecordedSize = 0;
      
      // 更新显示
      updateCacheDisplay();
      savedFilesSpan.textContent = "0 个";
      totalRecordedSpan.textContent = "0.00 MB";
      
      // 隐藏合并按钮
      mergeFilesBtn.style.display = "none";
    }
    
    // 使用 File System Access API 尝试删除文件
    async function tryDeleteWithFileSystemAPI(filesToDelete) {
      try {
        console.log("🔍 请求用户选择下载目录...");
        const directoryHandle = await window.showDirectoryPicker({
          mode: 'readwrite',
          startIn: 'downloads'
        });
        
        console.log("✅ 用户已选择目录，开始删除文件...");
        
        for (const file of filesToDelete) {
          try {
            await directoryHandle.removeEntry(file.fileName);
            console.log(`✅ 已删除: ${file.fileName}`);
          } catch (error) {
            console.log(`❌ 删除失败: ${file.fileName} - ${error.message}`);
          }
        }
        
        console.log("🎉 File System Access API 删除完成！");
        
      } catch (error) {
        console.log(`❌ File System Access API 失败: ${error.message}`);
        console.log("🔄 尝试其他方法...");
        tryAlternativeDeleteMethods(filesToDelete);
      }
    }
    
    // 尝试其他删除方法
    function tryAlternativeDeleteMethods(filesToDelete) {
      console.log("🔧 尝试其他删除方法...");
      
      // 方法2: 尝试使用 IndexedDB 存储文件引用，然后清理
      try {
        console.log("📦 尝试使用 IndexedDB 清理...");
        const request = indexedDB.open('WebRecorderFiles', 1);
        
        request.onerror = () => {
          console.log("❌ IndexedDB 不可用");
          fallbackToManualDelete(filesToDelete);
        };
        
        request.onsuccess = () => {
          const db = request.result;
          const transaction = db.transaction(['files'], 'readwrite');
          const store = transaction.objectStore('files');
          
          // 清理所有文件记录
          const clearRequest = store.clear();
          clearRequest.onsuccess = () => {
            console.log("✅ IndexedDB 清理完成");
          };
          clearRequest.onerror = () => {
            console.log("❌ IndexedDB 清理失败");
          };
        };
        
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains('files')) {
            db.createObjectStore('files');
          }
        };
        
      } catch (error) {
        console.log(`❌ IndexedDB 方法失败: ${error.message}`);
        fallbackToManualDelete(filesToDelete);
      }
      
      // 方法3: 尝试使用 Web Streams API
      try {
        console.log("🌊 尝试使用 Web Streams API...");
        filesToDelete.forEach(file => {
          // 尝试释放文件引用
          if (file.blob) {
            URL.revokeObjectURL(URL.createObjectURL(file.blob));
            console.log(`🔄 已释放文件引用: ${file.fileName}`);
          }
        });
      } catch (error) {
        console.log(`❌ Web Streams API 失败: ${error.message}`);
      }
      
      // 方法4: 尝试使用 Clipboard API 清理
      try {
        console.log("📋 尝试清理剪贴板...");
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText('').then(() => {
            console.log("✅ 剪贴板已清理");
          }).catch(() => {
            console.log("❌ 剪贴板清理失败");
          });
        }
      } catch (error) {
        console.log(`❌ Clipboard API 失败: ${error.message}`);
      }
      
      // 延迟检查是否成功
      setTimeout(() => {
        console.log("🔍 检查删除结果...");
        // 这里我们无法真正验证文件是否被删除，但可以清理内存
        console.log("✅ 内存数据已清理");
        console.log("💡 如果文件仍然存在，请手动删除");
      }, 1000);
    }
    
    // 回退到手动删除提示
    function fallbackToManualDelete(filesToDelete) {
      console.log("⚠️ 自动删除方法都失败了，回退到手动删除");
      console.log("📁 需要手动删除的源文件:");
      filesToDelete.forEach((file, index) => {
        console.log(`${index + 1}. ${file.fileName} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
      });
      console.log(`💡 提示: 这些文件在下载目录中，请手动删除以节省空间`);
    }
    
    // 合并选中的文件
    function mergeSelectedFiles() {
      const checkboxes = fileList.querySelectorAll('input[type="checkbox"]:checked');
      if (checkboxes.length === 0) {
        alert("请至少选择一个文件");
        return;
      }
      
      const selectedFiles = [];
      checkboxes.forEach(checkbox => {
        const index = parseInt(checkbox.id.split('_')[1]);
        selectedFiles.push(sessionFiles[index]);
      });
      
      // 按partNumber排序
      selectedFiles.sort((a, b) => a.partNumber.localeCompare(b.partNumber));
      
      console.log("开始合并文件:", selectedFiles.map(f => f.fileName));
      console.log("=== 合并文件路径信息 ===");
      selectedFiles.forEach((file, index) => {
        console.log(`${index + 1}. ${file.fileName}`);
        console.log(`   路径: 浏览器默认下载目录/${file.fileName}`);
        console.log(`   大小: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
      });
      
      // 实现真正的文件合并
      try {
        // 创建合并后的文件名
        const mergedFileName = `${currentWindowName}_${sessionId}_合并完成.webm`;
        
        // 由于浏览器限制，我们创建一个包含所有数据的Blob
        // 注意：这不是真正的视频合并，只是数据拼接
        const allChunks = [];
        selectedFiles.forEach(file => {
          // 这里我们无法直接读取已下载的文件，所以使用累积的数据
          console.log(`处理文件: ${file.fileName}`);
        });
        
        // 使用累积的数据创建合并文件
        const mergedBlob = new Blob(allRecordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(mergedBlob);
        
        // 创建下载链接
        const link = document.createElement('a');
        link.href = url;
        link.download = mergedFileName;
        link.style.display = 'none';
        document.body.appendChild(link);
        
        // 自动下载
        link.click();
        
        // 清理
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log(`✅ 合并完成: ${mergedFileName} (${(mergedBlob.size / 1024 / 1024).toFixed(2)} MB)`);
        console.log(`💾 合并文件已下载到: 浏览器默认下载目录/${mergedFileName}`);
        
        // 询问是否尝试自动删除源文件
        if (confirm(`✅ 合并完成！\n📁 合并文件: ${mergedFileName}\n📊 总大小: ${(mergedBlob.size / 1024 / 1024).toFixed(2)} MB\n\n是否尝试自动删除 ${selectedFiles.length} 个源文件？\n🔧 将尝试多种方法自动删除`)) {
          // 清理小文件信息（模拟删除）
          sessionFiles = [];
          savedFileCount = 0;
          allRecordedChunks = [];
          totalRecordedSize = 0;
          updateCacheDisplay();
          savedFilesSpan.textContent = "0 个";
          totalRecordedSpan.textContent = "0.00 MB";
          mergeFilesBtn.style.display = "none";
          
          console.log("✅ 源文件已删除，内存已清理");
        }
        
      } catch (error) {
        console.error("合并文件时出错:", error);
        alert("合并文件时出错，请重试。");
      }
      
      mergeDialog.style.display = 'none';
    }
    
    // 绑定合并文件按钮事件
    mergeFilesBtn.onclick = showMergeDialog;
    
    // 绑定合并对话框按钮事件
    confirmMergeBtn.onclick = mergeSelectedFiles;
    cancelMergeBtn.onclick = () => {
      mergeDialog.style.display = 'none';
    };
    
    // 监听阈值变化
    memoryThresholdSelect.addEventListener('change', () => {
      const threshold = memoryThresholdSelect.value;
      currentThresholdSpan.textContent = `当前阈值: ${threshold} MB`;
      console.log(`内存阈值已更改为: ${threshold} MB`);
    });
    
    // 监听录制模式变化
    recordingModeSelect.addEventListener('change', () => {
      const mode = recordingModeSelect.value;
      isSingleFileMode = (mode === 'single');
      console.log(`录制模式已更改为: ${isSingleFileMode ? '单文件模式' : '多文件模式'}`);
      
      if (isSingleFileMode) {
        console.log("📁 单文件模式: 所有数据将累积到一个文件中，录制结束时下载");
      } else {
        console.log("📁 多文件模式: 达到阈值时保存小文件，录制结束时可合并");
      }
    });
    
    // 初始化阈值显示
    currentThresholdSpan.textContent = `当前阈值: ${memoryThresholdSelect.value} MB`;

    startBtn.onclick = async () => {
      try {
        // 生成新的会话ID
        sessionId = generateSessionId();
        sessionFiles = [];
        allRecordedChunks = []; // 初始化总累积数据
        currentFileBlob = null; // 初始化当前文件Blob
        finalFileName = ""; // 初始化最终文件名
        
        console.log("开始新的录制会话，ID:", sessionId);
        console.log("=== 录制配置信息 ===");
        console.log("录制模式:", isSingleFileMode ? "单文件模式" : "多文件模式");
        console.log("内存阈值:", memoryThresholdSelect.value, "MB");
        if (isSingleFileMode) {
          console.log("文件命名格式: [录制名称]_[会话ID]_完整录制.webm");
          console.log("保存方式: 累积所有数据，录制结束时下载单个文件");
        } else {
          console.log("文件命名格式: [录制名称]_[会话ID]_part[序号].webm");
          console.log("保存方式: 达到阈值时保存小文件，录制结束时可合并");
        }
        console.log("保存路径: 浏览器默认下载目录");
        console.log("==================");
        
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
        preview.srcObject = stream;

        // 获取窗口信息
        currentWindowName = "未知窗口";
        if (stream.getVideoTracks && stream.getVideoTracks()[0]) {
          const videoTrack = stream.getVideoTracks()[0];
          const settings = videoTrack.getSettings();
          
          // 详细调试信息
          console.log("=== 录制信息调试 ===");
          console.log("Video track label (原始):", videoTrack.label);
          console.log("Video track label (类型):", typeof videoTrack.label);
          console.log("Video track label (长度):", videoTrack.label ? videoTrack.label.length : 0);
          console.log("Display surface:", settings.displaySurface);
          console.log("All settings:", settings);
          console.log("Video track 对象:", videoTrack);
          console.log("Stream 对象:", stream);
          
          // 尝试获取更多信息
          if (videoTrack.label) {
            console.log("Label 是否包含 web-contents:", videoTrack.label.includes('web-contents'));
            console.log("Label 是否包含 http:", videoTrack.label.includes('http'));
            console.log("Label 是否包含 title:", videoTrack.label.includes('title'));
            console.log("Label 字符编码:", videoTrack.label.split('').map(c => c.charCodeAt(0)));
          }
          
          // 生成有意义的名称
          const now = new Date();
          const timestamp = now.getFullYear() + 
            String(now.getMonth() + 1).padStart(2, '0') + 
            String(now.getDate()).padStart(2, '0') + '_' +
            String(now.getHours()).padStart(2, '0') + 
            String(now.getMinutes()).padStart(2, '0') + 
            String(now.getSeconds()).padStart(2, '0');
          
          // 根据显示表面类型生成名称
          if (settings.displaySurface === 'window') {
            // 尝试从标签获取应用程序名称
            if (videoTrack.label && videoTrack.label.trim() !== '') {
              let appName = videoTrack.label;
              // 移除可能的内部标识符
              appName = appName.replace(/^[a-f0-9-]+$/, ''); // 移除纯十六进制ID
              if (appName.trim() !== '') {
                currentWindowName = `${appName}_${timestamp}`;
              } else {
                currentWindowName = `应用程序窗口_${timestamp}`;
              }
            } else {
              currentWindowName = `应用程序窗口_${timestamp}`;
            }
          } else if (settings.displaySurface === 'browser') {
            // Chrome 不会在 label 中提供页面标题，使用默认名称
            currentWindowName = `浏览器标签页_${timestamp}`;
            console.log("Chrome 不提供页面标题，使用默认名称。用户可以在下方输入自定义标题。");
          } else if (settings.displaySurface === 'monitor') {
            currentWindowName = `整个屏幕_${timestamp}`;
          } else {
            currentWindowName = `录制_${timestamp}`;
          }
        } else {
          // 备用方案：使用当前时间
          const now = new Date();
          const timestamp = now.getFullYear() + 
            String(now.getMonth() + 1).padStart(2, '0') + 
            String(now.getDate()).padStart(2, '0') + '_' +
            String(now.getHours()).padStart(2, '0') + 
            String(now.getMinutes()).padStart(2, '0') + 
            String(now.getSeconds()).padStart(2, '0');
          currentWindowName = `录制_${timestamp}`;
        }

        console.log("最终窗口名称:", currentWindowName);
        
        // 显示窗口信息
        windowNameSpan.textContent = currentWindowName;
        windowInfo.style.display = "block";
        
        // 输出详细的文件路径信息
        console.log("=== 录制文件路径信息 ===");
        console.log("录制名称:", currentWindowName);
        console.log("会话ID:", sessionId);
        console.log("文件前缀:", `${currentWindowName}_${sessionId}`);
        console.log("文件扩展名: .webm");
        console.log("保存位置: 浏览器默认下载目录");
        console.log("完整路径示例: 浏览器默认下载目录/产品演示_20241220_143052_part001.webm");
        console.log("=========================");

        recordedChunks = [];
        console.log("初始化录制变量:");
        console.log("- recordedChunks 长度:", recordedChunks.length);
        console.log("- cacheSizeSpan DOM元素:", cacheSizeSpan);
        console.log("- savedFilesSpan DOM元素:", savedFilesSpan);
        
        mediaRecorder = new MediaRecorder(stream, { 
          mimeType: "video/webm",
          videoBitsPerSecond: 2500000 // 设置视频比特率
        });
        console.log("MediaRecorder 已创建:", mediaRecorder);
        console.log("MediaRecorder 状态:", mediaRecorder.state);
        console.log("MediaRecorder MIME类型:", mediaRecorder.mimeType);

        // 绑定ondataavailable事件
        mediaRecorder.ondataavailable = e => {
          console.log(`🔔 ondataavailable事件触发! 数据大小: ${e.data ? e.data.size : 'undefined'} 字节`);
          
          if (e.data && e.data.size > 0) {
            // 添加到当前缓存
            recordedChunks.push(e.data);
            // 同时添加到总累积数据
            allRecordedChunks.push(e.data);
            
            // 计算当前缓存大小
            const currentCacheSize = recordedChunks.reduce((total, chunk) => total + chunk.size, 0);
            const currentCacheSizeMB = (currentCacheSize / 1024 / 1024).toFixed(2);
            
            // 计算总累积大小
            const totalAccumulatedSize = allRecordedChunks.reduce((total, chunk) => total + chunk.size, 0);
            const totalAccumulatedSizeMB = (totalAccumulatedSize / 1024 / 1024).toFixed(2);
            
            // 详细的数据变化日志
            console.log(`📥 新数据块: ${e.data.size} 字节 (${(e.data.size / 1024).toFixed(2)} KB)`);
            console.log(`📊 当前缓存: ${currentCacheSizeMB} MB (${recordedChunks.length} 个数据块)`);
            console.log(`📈 总累积: ${totalAccumulatedSizeMB} MB (${allRecordedChunks.length} 个数据块)`);
            console.log(`🎯 阈值: ${memoryThresholdSelect.value} MB`);
            console.log(`---`);
            
            // 立即更新显示，确保用户看到实时变化
            updateCacheDisplay(true);
            
            // 添加视觉反馈
            if (cacheSizeSpan) {
              cacheSizeSpan.classList.add('cache-updating');
              setTimeout(() => {
                cacheSizeSpan.classList.remove('cache-updating');
              }, 300);
            }
            
            // 检查是否需要保存（流式录制模式）
            if (isStreamingMode) {
              checkMemoryThreshold();
            }
          } else {
            console.warn("⚠️ 接收到空数据块或无效数据");
            console.log("事件对象:", e);
            console.log("数据对象:", e.data);
          }
        };
        
        // 添加其他事件监听器用于调试
        mediaRecorder.onstart = () => {
          console.log("🎬 MediaRecorder 开始录制");
        };
        
        mediaRecorder.onpause = () => {
          console.log("⏸️ MediaRecorder 暂停录制");
        };
        
        mediaRecorder.onresume = () => {
          console.log("▶️ MediaRecorder 恢复录制");
        };
        
        mediaRecorder.onerror = (e) => {
          console.error("❌ MediaRecorder 错误:", e);
        };

        mediaRecorder.onstop = () => {
          // 保存最后的缓存数据
          if (recordedChunks.length > 0) {
            saveCurrentChunks();
          }
          
          // 单文件模式：保存最后的内存数据
          if (isSingleFileMode && memoryChunks.length > 0) {
            saveMemoryToDisk();
          }
          
          if (isSingleFileMode) {
            // 单文件模式：生成最终文件
            if (allRecordedChunks.length > 0) {
              finalFileName = `${currentWindowName}_${sessionId}_完整录制.webm`;
              const finalBlob = new Blob(allRecordedChunks, { type: "video/webm" });
              const url = URL.createObjectURL(finalBlob);
              
              // 创建下载链接并自动下载
              const link = document.createElement('a');
              link.href = url;
              link.download = finalFileName;
              link.style.display = 'none';
              document.body.appendChild(link);
              
              // 延迟一点时间确保链接准备就绪
              setTimeout(() => {
                link.click();
                // 清理
                setTimeout(() => {
                  document.body.removeChild(link);
                  URL.revokeObjectURL(url);
                }, 100);
              }, 50);
              
              console.log("🎉 单文件录制完成！");
              console.log(`📁 最终文件名: ${finalFileName}`);
              console.log(`📊 最终总大小: ${(finalBlob.size / 1024 / 1024).toFixed(2)} MB`);
              console.log(`📈 总数据块: ${allRecordedChunks.length} 个`);
              console.log(`💾 文件路径: 浏览器默认下载目录/${finalFileName}`);
              console.log(`✅ 单文件模式：只生成一个最终完整文件`);
              
              // 更新文件路径显示为最终文件
              updateFilePathDisplay(finalFileName);
              
              console.log(`🎉 录制完成！\n📁 最终文件: ${finalFileName}\n📊 总大小: ${(finalBlob.size / 1024 / 1024).toFixed(2)} MB\n📈 数据块: ${allRecordedChunks.length} 个\n\n文件已自动下载到默认下载目录！`);
            } else {
              alert("录制完成！没有数据需要保存。");
            }
          } else {
            // 多文件模式：显示合并选项
            clearMemoryBtn.style.display = "inline-block";
            if (sessionFiles.length > 1) {
              mergeFilesBtn.style.display = "inline-block";
            }
            
            console.log("录制完成！");
            console.log(`会话ID: ${sessionId}`);
            console.log(`总共保存了 ${sessionFiles.length} 个文件`);
            
            if (sessionFiles.length > 0) {
              const totalSize = sessionFiles.reduce((sum, file) => sum + file.size, 0);
              const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);
              console.log(`录制完成！\n会话ID: ${sessionId}\n已自动保存 ${sessionFiles.length} 个文件到下载目录。\n总大小: ${totalSizeMB} MB`);
              
              // 多文件模式自动合并
              if (sessionFiles.length > 1) {
                console.log(`🔄 自动开始合并 ${sessionFiles.length} 个文件...`);
                setTimeout(() => {
                  autoMergeFiles();
                }, 1000); // 延迟1秒确保所有文件下载完成
              }
            } else {
              alert("录制完成！没有数据需要保存。");
            }
          }
        };

        // 启动录制，设置timeslice确保定期触发ondataavailable事件
        const timeslice = 1000; // 每1秒触发一次ondataavailable事件
        mediaRecorder.start(timeslice);
        console.log(`🎬 开始录制，timeslice: ${timeslice}ms`);
        console.log(`📊 录制状态: ${mediaRecorder.state}`);
        
        startBtn.disabled = true;
        stopBtn.disabled = false;
        updateRecordingStatus("正在录制");
        
        // 禁用设置控件
        toggleSettingsEnabled(false);
        
        // 启动定时更新器，确保显示持续更新
        updateTimer = setInterval(() => {
          if (recordedChunks.length > 0) {
            updateCacheDisplay();
          }
        }, 100); // 每100ms更新一次
        
        // 监听共享状态变化
        stream.getTracks().forEach(track => {
          track.addEventListener('ended', () => {
            console.log("检测到共享已结束 (轨道类型:", track.kind, ")");
            handleRecordingStop();
          });
        });
      } catch (err) {
        alert("捕获屏幕失败: " + err);
      }
    };

    stopBtn.onclick = () => {
      console.log("用户点击停止录制");
      handleRecordingStop();
    };
  </script>
</body>
</html>